#include <iostream>
#include <string>
#include <cstdlib>
//using namespace std;


void input(char *buff, short size, FILE *fin, FILE *fout);

short sizeof_file(FILE *fin);

short count_str(char *buff, short size, FILE *fin, FILE *fout);

short* Choose_Point(char *buff, short *numbers_of_str,
	short count_of_str, short size, FILE *fin, FILE *fout);

void Mistakes_Checker(char *buff, short size, FILE *fin, FILE *fout);


int compare_function(const void *name1, const void *name2);


int main()
{
	FILE *fin, *fout;
	fopen_s(&fin, "INPUT.txt", "r");
	fopen_s(&fout, "OUTPUT.txt", "w");

	

	
	if (!fin)
	{
		fprintf(fout, "File was not open");
	}
	else
	{
		short sizebuff = sizeof_file(fin);
		char *buff = (char*)calloc(sizebuff++, sizeof(char));// ++

		input(buff, sizebuff, fin, fout);

		short count_of_str = count_str(buff, sizebuff, fin, fout) + 1;

		char **p = new char*[count_of_str];

		short *numbers_of_str = new short[count_of_str];
		// array with the way between pointers

		numbers_of_str = Choose_Point(buff, numbers_of_str, count_of_str,
			sizebuff, fin, fout);
		
		for (int counter(0); counter < count_of_str; ++counter)
			p[counter] = &buff[numbers_of_str[counter]];

		qsort(p, count_of_str, sizeof(char *), compare_function);

		for (int counter(0); counter < count_of_str; ++counter)
			fprintf(fout, "%s\n", p[counter]);

		/*for (int i(0); i < count_of_str; ++i)
		cout << numbers_of_str[i]<< ends << buff[numbers_of_str[i]] << endl;*/


		// !!!!!! if in real count_of_str==0  we get count_of_str==1
		
		free(buff);
		delete numbers_of_str;

	}
	
	
	fclose(fin);
	fclose(fout);
	system("pause");
}


short sizeof_file(FILE *fin)
{
	fseek(fin, 0, SEEK_END);

	short size(ftell(fin));

	fseek(fin, 0, SEEK_SET);

	return size;
}


void input(char *buff, short size, FILE *fin, FILE *fout)
{
	fread(buff, sizeof(char), size, fin);
}


short count_str(char *buff, short size, FILE *fin, FILE *fout)
{
	short count_of_str(0);
	for (short counter(0); counter<size; counter++)
		if (buff[counter] == '\n')
		{
			count_of_str++;
			buff[counter] = '\0';
		}
	return count_of_str;
}


short number_str(char *buff, short size, FILE *fin, FILE *fout)
{
	short count_str(0);
	for (short counter(0); counter<size; counter++)
		if (buff[counter] == '\n')
		{
			count_str++;
			buff[counter] = '\0';
		}
	return count_str;
}


short* Choose_Point(char *buff, short *numbers_of_str,
	short count_of_str, short size, FILE *fin, FILE *fout)
{

	short count_points(1);
	numbers_of_str[0] = 0;

	for (short counter(1); counter < size; ++counter)
	{
		if ((buff[counter] == '\0')&&(count_points<count_of_str))
		{
			numbers_of_str[count_points] = counter + 1;
			count_points++;
		}

	}
	return (numbers_of_str);
}




void Mistakes_Checker(char *buff, short size, FILE *fin, FILE *fout)
{
	for (short counter(0); counter < size; ++counter)
		fprintf(fout, "%s\n", buff[counter]);
}


int compare_function(const void *name1, const void *name2)
{
	const char *name1_ = *(const char **)name1;
	const char *name2_ = *(const char **)name2;
	return strcmp(name1_, name2_);
}
